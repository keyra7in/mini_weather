/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2024 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include <stdio.h>
#include <string.h>
/* USER CODE END Includes */
#include "ILI9341.h"
/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */

/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
#define LCD_CS_LOW()     HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_RESET)
#define LCD_CS_HIGH()    HAL_GPIO_WritePin(LCD_CS_PORT, LCD_CS_PIN, GPIO_PIN_SET)
#define LCD_DC_CMD()     HAL_GPIO_WritePin(LCD_DC_PORT, LCD_DC_PIN, GPIO_PIN_RESET)
#define LCD_DC_DATA()    HAL_GPIO_WritePin(LCD_DC_PORT, LCD_DC_PIN, GPIO_PIN_SET)
#define LCD_RST_LOW()    HAL_GPIO_WritePin(LCD_RST_PORT, LCD_RST_PIN, GPIO_PIN_RESET)
#define LCD_RST_HIGH()   HAL_GPIO_WritePin(LCD_RST_PORT, LCD_RST_PIN, GPIO_PIN_SET)
#ifdef __GNUC__
/* With GCC, small printf (option LD Linker->Libraries->Small printf
   set to 'Yes') calls __io_putchar() */
#define PUTCHAR_PROTOTYPE int __io_putchar(int ch)
#else
#define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)
#endif /* __GNUC__ */
#define ARR_CNT 5
#define CMD_SIZE 50
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
I2C_HandleTypeDef hi2c3;

RTC_HandleTypeDef hrtc;

SPI_HandleTypeDef hspi2;

UART_HandleTypeDef huart2;
UART_HandleTypeDef huart6;

/* USER CODE BEGIN PV */
uint8_t rx2char;
volatile unsigned char rx2Flag = 0;
volatile char rx2Data[50];
volatile unsigned char btFlag = 0;
uint8_t btchar;
char btData[50];
static uint8_t prev_sec = 99;
char city_name[20];
//char weekDayName[10] = "---";

RTC_TimeTypeDef sTime = {0};
RTC_DateTypeDef sDate = {0};
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_USART2_UART_Init(void);
static void MX_USART6_UART_Init(void);
static void MX_I2C3_Init(void);
static void MX_SPI2_Init(void);
static void MX_RTC_Init(void);
/* USER CODE BEGIN PFP */
void bluetooth_Event();
void Update_RTC_From_Server(char* msg);
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{

  /* USER CODE BEGIN 1 */

  /* USER CODE END 1 */

  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();

  /* USER CODE BEGIN Init */

  /* USER CODE END Init */

  /* Configure the system clock */
  SystemClock_Config();

  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
  MX_USART2_UART_Init();
  MX_USART6_UART_Init();
  MX_I2C3_Init();
  MX_SPI2_Init();
  MX_RTC_Init();
  /* USER CODE BEGIN 2 */
  HAL_UART_Receive_IT(&huart2, &rx2char,1);
  HAL_UART_Receive_IT(&huart6, &btchar,1);
  ILI9341_Init();
  ILI9341_FillScreen(BLACK);
  printf("start main2()\r\n");

  // 상단 제목
  ILI9341_DrawString_Size(20, 10, "WEATHER STATION", WHITE, BLACK, 1);
//
//  // 날씨 아이콘 출력 테스트
//  ILI9341_DrawSunny(120, 80);    // 화면 중앙 상단에 해
//  ILI9341_DrawString_Size(80, 120, "SUNNY", YELLOW, BLACK, 2);
//
//  // 기온 표시
//  ILI9341_DrawString_Size(50, 160, "25.4 C", CYAN, BLACK, 3);
//  char buf[10] = "Hello\r";
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
  {
	  if(rx2Flag)
	  {
			printf("recv2 : %s\r\n",rx2Data);
			rx2Flag =0;
	//	    HAL_UART_Transmit(&huart6, (uint8_t *)buf, strlen(buf), 0xFFFF);
	  }
	  if(btFlag)
	  {

		  bluetooth_Event();
		  btFlag = 0;
		}


	  // 1. RTC로부터 현재 시간 읽기
	        HAL_RTC_GetTime(&hrtc, &sTime, RTC_FORMAT_BIN);
	        HAL_RTC_GetDate(&hrtc, &sDate, RTC_FORMAT_BIN);

	        // 2. 1초에 한 번만 LCD 갱신
	        if (sTime.Seconds != prev_sec) {
	            char timeBuf[20], dateBuf[30];

	            // 날짜와 시간 문자열 만들기
	            sprintf(dateBuf, "20%02d.%02d.%02d", sDate.Year, sDate.Month, sDate.Date);
	            sprintf(timeBuf, "%02d:%02d:%02d", sTime.Hours, sTime.Minutes, sTime.Seconds);

	            // 이전 잔상을 지우기 위해 배경색과 같은 색으로 덮어쓰거나
	            // 폰트 라이브러리에서 배경색을 지원한다면 그대로 출력
	            ILI9341_DrawString_Size(10, 260, dateBuf, WHITE, BLACK, 1);
	            ILI9341_DrawString_Size(10, 280, timeBuf, CYAN, BLACK, 2);

	            prev_sec = sTime.Seconds;

	            // 디버그용 출력 (선택 사항)
	            // printf("RTC Time: %s\r\n", timeBuf);
	        }

	        HAL_Delay(10); // 루프 속도 조절 (너무 빠르면 CPU 점유율이 높음)
//	  HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
//	  HAL_Delay(500);

    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
  }
  /* USER CODE END 3 */
}

/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  /** Configure the main internal regulator output voltage
  */
  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_LSE;
  RCC_OscInitStruct.LSEState = RCC_LSE_ON;
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
  RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
  RCC_OscInitStruct.PLL.PLLM = 16;
  RCC_OscInitStruct.PLL.PLLN = 336;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
  RCC_OscInitStruct.PLL.PLLQ = 4;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }

  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
  {
    Error_Handler();
  }
}

/**
  * @brief I2C3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_I2C3_Init(void)
{

  /* USER CODE BEGIN I2C3_Init 0 */

  /* USER CODE END I2C3_Init 0 */

  /* USER CODE BEGIN I2C3_Init 1 */

  /* USER CODE END I2C3_Init 1 */
  hi2c3.Instance = I2C3;
  hi2c3.Init.ClockSpeed = 100000;
  hi2c3.Init.DutyCycle = I2C_DUTYCYCLE_2;
  hi2c3.Init.OwnAddress1 = 0;
  hi2c3.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
  hi2c3.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
  hi2c3.Init.OwnAddress2 = 0;
  hi2c3.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
  hi2c3.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
  if (HAL_I2C_Init(&hi2c3) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN I2C3_Init 2 */

  /* USER CODE END I2C3_Init 2 */

}

/**
  * @brief RTC Initialization Function
  * @param None
  * @retval None
  */
static void MX_RTC_Init(void)
{

  /* USER CODE BEGIN RTC_Init 0 */

  /* USER CODE END RTC_Init 0 */

//  RTC_TimeTypeDef sTime = {0};
//  RTC_DateTypeDef sDate = {0};

  /* USER CODE BEGIN RTC_Init 1 */

  /* USER CODE END RTC_Init 1 */

  /** Initialize RTC Only
  */
  hrtc.Instance = RTC;
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
  hrtc.Init.AsynchPrediv = 127;
  hrtc.Init.SynchPrediv = 255;
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
  {
    Error_Handler();
  }

  /* USER CODE BEGIN Check_RTC_BKUP */

  /* USER CODE END Check_RTC_BKUP */

  /** Initialize RTC and set the Time and Date
  */
  sTime.Hours = 0x0;
  sTime.Minutes = 0x0;
  sTime.Seconds = 0x0;
  sTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
  sTime.StoreOperation = RTC_STOREOPERATION_RESET;
  if (HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BCD) != HAL_OK)
  {
    Error_Handler();
  }
  sDate.WeekDay = RTC_WEEKDAY_MONDAY;
  sDate.Month = RTC_MONTH_JANUARY;
  sDate.Date = 0x1;
  sDate.Year = 0x0;

  if (HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BCD) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN RTC_Init 2 */

  /* USER CODE END RTC_Init 2 */

}

/**
  * @brief SPI2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_SPI2_Init(void)
{

  /* USER CODE BEGIN SPI2_Init 0 */

  /* USER CODE END SPI2_Init 0 */

  /* USER CODE BEGIN SPI2_Init 1 */

  /* USER CODE END SPI2_Init 1 */
  /* SPI2 parameter configuration*/
  hspi2.Instance = SPI2;
  hspi2.Init.Mode = SPI_MODE_MASTER;
  hspi2.Init.Direction = SPI_DIRECTION_2LINES;
  hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
  hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;
  hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
  hspi2.Init.NSS = SPI_NSS_SOFT;
  hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;
  hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
  hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  hspi2.Init.CRCPolynomial = 10;
  if (HAL_SPI_Init(&hspi2) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN SPI2_Init 2 */

  /* USER CODE END SPI2_Init 2 */

}

/**
  * @brief USART2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART2_UART_Init(void)
{

  /* USER CODE BEGIN USART2_Init 0 */

  /* USER CODE END USART2_Init 0 */

  /* USER CODE BEGIN USART2_Init 1 */

  /* USER CODE END USART2_Init 1 */
  huart2.Instance = USART2;
  huart2.Init.BaudRate = 115200;
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart2) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART2_Init 2 */

  /* USER CODE END USART2_Init 2 */

}

/**
  * @brief USART6 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART6_UART_Init(void)
{

  /* USER CODE BEGIN USART6_Init 0 */

  /* USER CODE END USART6_Init 0 */

  /* USER CODE BEGIN USART6_Init 1 */

  /* USER CODE END USART6_Init 1 */
  huart6.Instance = USART6;
  huart6.Init.BaudRate = 9600;
  huart6.Init.WordLength = UART_WORDLENGTH_8B;
  huart6.Init.StopBits = UART_STOPBITS_1;
  huart6.Init.Parity = UART_PARITY_NONE;
  huart6.Init.Mode = UART_MODE_TX_RX;
  huart6.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart6.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart6) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN USART6_Init 2 */

  /* USER CODE END USART6_Init 2 */

}

/**
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  /* USER CODE BEGIN MX_GPIO_Init_1 */
  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, LCD_DC_Pin|GPIO_PIN_14|LCD_CS_Pin|TEST_LED_Pin
                          |MOTOR_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin : B1_Pin */
  GPIO_InitStruct.Pin = B1_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : LD2_Pin */
  GPIO_InitStruct.Pin = LD2_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pins : LCD_DC_Pin PB14 LCD_CS_Pin TEST_LED_Pin
                           MOTOR_Pin */
  GPIO_InitStruct.Pin = LCD_DC_Pin|GPIO_PIN_14|LCD_CS_Pin|TEST_LED_Pin
                          |MOTOR_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  /* USER CODE BEGIN MX_GPIO_Init_2 */
  /* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */
void Update_RTC_From_Server(char* msg) {
    int year, month, day, hour, min, sec;
    //char week_s[10] = {0};
    // [GETTIME]26/01/12/13/45/00 포맷 파싱
    if (sscanf(msg, "[GETTIME]%d.%d.%d %d:%d:%d", &year, &month, &day, &hour, &min, &sec) == 6) {

    	sTime.Hours = (uint8_t)hour;
		sTime.Minutes = (uint8_t)min;
		sTime.Seconds = (uint8_t)sec;
		HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BIN);

		sDate.Year = (uint8_t)year;
		sDate.Month = (uint8_t)month;
		sDate.Date = (uint8_t)day;
		HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BIN);

		//strcpy(weekDayName, week_s);

		printf("RTC Sync Success!\r\n");;
    }
}
void MX_GPIO_LED_ON(int pin)
{
	HAL_GPIO_WritePin(TEST_LED_GPIO_Port, TEST_LED_Pin, GPIO_PIN_SET);
}
void MX_GPIO_LED_OFF(int pin)
{
	HAL_GPIO_WritePin(TEST_LED_GPIO_Port, TEST_LED_Pin, GPIO_PIN_RESET);
}
void bluetooth_Event()
{
//	// 1. 받은 데이터가 시간([GETTIME])이나 날씨([TEMP])라면 서버로 되돌려보내지 않고 종료

//	  }
  int i=0;
  char * pToken;
  char * pArray[ARR_CNT]={0};
  char recvBuf[CMD_SIZE]={0};
  char sendBuf[CMD_SIZE]={0};
  static char prev_weather = ' ';  // 이전 날씨 상태 저장
  static int prev_temp = -999;     // 이전 기온 저장

//  if(btData[0] == '\0' || btData[0] == '\r' || btData[0] == '\n') {
//        btFlag = 0;
//        return;
//    }

  strcpy(recvBuf,btData);

  printf("btData : %s\r\n",btData);

  pToken = strtok(recvBuf,"[@]");
  while(pToken != NULL)
  {
    pArray[i] =  pToken;
    if(++i >= ARR_CNT)
      break;
    pToken = strtok(NULL,"[@]");
  }
  if(pArray[0] == NULL) return;


  if (strcmp(pArray[0], "GETTIME") == 0) {
	  if (strstr((char*)btData, "[GETTIME]") != NULL) {
		  Update_RTC_From_Server((char*)btData);
	  }
    }

  if(strcmp(pArray[1], "LED") == 0 && strcmp(pArray[2], "ON") == 0)
    {
        // A. ARD용 전송: [CSB_ARD]LED@ON
        sprintf(sendBuf, "[CSB_ARD]%s@%s\n", pArray[1], pArray[2]);
        HAL_UART_Transmit(&huart6, (uint8_t *)sendBuf, strlen(sendBuf), 0xFFFF);
        //printf("Sent to ARD: %s\r\n", sendBuf);

        HAL_Delay(50);

        // B. WEATHER용 전송: [WEATHER]LEDON (두 단어를 합침)
        sprintf(sendBuf, "[WEATHER]%s%s\n", pArray[1], pArray[2]);
        HAL_UART_Transmit(&huart6, (uint8_t *)sendBuf, strlen(sendBuf), 0xFFFF);
        //printf("Sent to WEATHER: %s\r\n", sendBuf);
    }
    // 2. WEATHER로 보내는 조건 확인
    // 만약 아두이노가 "[WEATHER]LEDON" 이라고 보냈다면 pArray[0]이 "WEATHER"가 됨
  else if(strcmp(pArray[1], "LEDON") == 0)
    {
        // 라즈베리 파이 서버가 인식할 수 있는 형식으로 재조립
        sprintf(sendBuf, "[WEATHER]%s\n", pArray[1]);
        // 블루투스가 연결된 UART(예: huart6)로 전송
        HAL_UART_Transmit(&huart6, (uint8_t *)sendBuf, strlen(sendBuf), 0xFFFF);
        printf("Sent to Raspberry Pi (WEATHER): %s\r", sendBuf);
    }
  else if(strcmp(pArray[1], "CITY") == 0)
    {
        // 라즈베리 파이 서버가 인식할 수 있는 형식으로 재조립
        sprintf(sendBuf, "[WEATHER]%s@%s\n", pArray[1], pArray[2]);
        // 블루투스가 연결된 UART(예: huart6)로 전송
        HAL_UART_Transmit(&huart6, (uint8_t *)sendBuf, strlen(sendBuf), 0xFFFF);
        printf("Sent to Raspberry Pi (WEATHER): %s\r", sendBuf);
    }

    else if (strstr((char*)btData, "TEMP@") != NULL) {
	  char *real_data = strstr((char*)btData, "TEMP@"); // "TEMP@25@S" 시작점 찾기

	  int t_num = 999;
	  char w_s[20] = {0};
	  // sscanf를 사용하여 @ 구분자로 데이터 추출
	  // TEMP@%d@%c 형식을 정확히 읽어옵니다.
	  if (sscanf(real_data, "TEMP@%d@%[^@]@%[^@\n]", &t_num, &w_s, city_name) >= 3)
	  {
		  // A. 날씨 아이콘 및 상태 텍스트 업데이트 (상태가 바뀔 때만)
			if (w_s != prev_weather) {
				// 1. 기존 아이콘 및 텍스트 영역 삭제 (검은색 사각형으로 덮기)
				// 아이콘 영역: x(80~160), y(20~100) / 텍스트 영역: x(80~160), y(100~120)
				// 라이브러리에 사각형 채우기 함수가 있다면 사용하세요 (예: ILI9341_DrawRectangle 또는 Fill)
				ILI9341_FillRectangle(40, 20, 160, 100, BLACK); // 아이콘+텍스트 통합 삭제 영역

				if (strcmp(w_s, "clear sky") == 0) {
					ILI9341_DrawSunny(120, 60);
					ILI9341_DrawString_Size(80, 100, "SUNNY ", YELLOW, BLACK, 2);
				}
				else  {
					ILI9341_DrawCloudy(120, 60);
					ILI9341_DrawString_Size(80, 100, "CLOUDY", WHITE, BLACK, 2);
				}

				prev_weather = w_s; // 현재 상태 저장
			}

			// B. 기온 업데이트 (온도가 바뀔 때만)
			if (t_num != prev_temp) {
				// 기온 표시 영역 삭제 (기존 숫자 지우기)
				ILI9341_FillRectangle(50, 140, 150, 40, BLACK);

				char t_buf[15];
				sprintf(t_buf, "%d C", t_num);
				ILI9341_DrawString_Size(60, 140, t_buf, CYAN, BLACK, 3);

				prev_temp = t_num; // 현재 기온 저장
			}
			ILI9341_FillRectangle(0, 200, 240, 30, BLACK);
			ILI9341_DrawString_Size(10, 200, city_name, WHITE, BLACK, 2);
			//printf("%s",city_name);
			printf("Parsing Success: Temp %d, Status %s\r\n", t_num, w_s);
	  }

    }

    else
    {
        // 그 외의 경우 아두이노(ARD) 제어용으로 전송
        if(pArray[1] != NULL && pArray[2] != NULL) {
            sprintf(sendBuf, "[CSB_ARD]%s@%s\n", pArray[1], pArray[2]);
            HAL_UART_Transmit(&huart6, (uint8_t *)sendBuf, strlen(sendBuf), 0xFFFF);
        }
    }
    btFlag = 0;

        // 2. 버퍼를 0으로 꽉 채워서 다음 데이터를 깨끗하게 받을 준비를 합니다.
    memset((void*)btData, 0, sizeof(btData));
}
/**
  * @brief  Retargets the C library printf function to the USART.
  * @param  None
  * @retval None
  */
PUTCHAR_PROTOTYPE
{
  /* Place your implementation of fputc here */
  /* e.g. write a character to the USART6 and Loop until the end of transmission */
  HAL_UART_Transmit(&huart2, (uint8_t *)&ch, 1, 0xFFFF);

  return ch;
}
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
    if(huart->Instance == USART2)
    {
    	static int i=0;
    	rx2Data[i] = rx2char;
    	if((rx2Data[i] == '\r')||(rx2Data[i] == '\n'))
    	{
    		rx2Data[i] = '\0';
    		rx2Flag = 1;
    		i = 0;
    	}
    	else
    	{
    		i++;
    	}
    	HAL_UART_Receive_IT(&huart2, &rx2char,1);
    }
    if(huart->Instance == USART6)
    {
    	//HAL_GPIO_TogglePin(LD2_GPIO_Port, LD2_Pin);
    	static int i=0;
    	btData[i] = btchar;
    	if((btData[i] == '\n') || btData[i] == '\r')
    	{
    		btData[i] = '\0';
    		btFlag = 1;
    		i = 0;
    	}
    	else
    	{
    		i++;
    	}
    	HAL_UART_Receive_IT(&huart6, &btchar,1);
    }
}
/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}
#ifdef USE_FULL_ASSERT
/**
  * @brief  Reports the name of the source file and the source line number
  *         where the assert_param error has occurred.
  * @param  file: pointer to the source file name
  * @param  line: assert_param error line source number
  * @retval None
  */
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
